<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATLAS | Segmento Urbano</title>
    
    <!-- React & ReactDOM (UMD for browser) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel (to compile JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- PDF & Canvas Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600&family=Oswald:wght@300;400&display=swap" rel="stylesheet">

    <style>
        /* ALLOW SCROLLING */
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; overflow-y: auto; overflow-x: hidden; }
        .leaflet-container { height: 100%; width: 100%; z-index: 0; }
        
        /* Typography for Architectural look */
        .font-arch { font-family: 'Oswald', sans-serif; }
        
        /* Custom Context Menu */
        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            border-radius: 0.125rem;
            z-index: 1000;
            min-width: 160px;
            overflow: hidden;
            animation: fadeIn 0.1s ease-out;
        }
        .context-menu-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            color: #374151;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: background-color 0.1s;
        }
        .context-menu-item:hover { background-color: #f3f4f6; }
        
        /* Metadata Overlay */
        .metadata-overlay {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(4px);
            box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e7eb;
        }

        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #525252; border-radius: 0px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #000; }

        /* Drawing Cursor - Finer Crosshair with larger gap */
        .drawing-mode, 
        .drawing-mode .leaflet-grab,
        .drawing-mode .leaflet-interactive {
            cursor: url("data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3C!-- White Outline --%3E%3Cpath d='M12 2V8 M12 16V22 M2 12H8 M16 12H22' stroke='white' stroke-width='2.5' stroke-linecap='square'/%3E%3Ccircle cx='12' cy='12' r='2' fill='white'/%3E%3C!-- Black Fine Lines --%3E%3Cpath d='M12 2V8 M12 16V22 M2 12H8 M16 12H22' stroke='black' stroke-width='1' stroke-linecap='square'/%3E%3Ccircle cx='12' cy='12' r='1' fill='black'/%3E%3C/svg%3E") 12 12, crosshair !important;
        }

        /* Panning Cursor Override during Right-Click drag in Drawing Mode */
        .drawing-panning,
        .drawing-panning .leaflet-grab,
        .drawing-panning .leaflet-interactive,
        .drawing-panning .leaflet-container {
            cursor: grabbing !important;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Translations ---
        const TRANSLATIONS = {
            en: {
                searchPlaceholder: "Search Address or GPS...",
                locate: "Locate",
                upload: "Upload",
                uploadTooltip: "PDM maps, Territory Tax certificate",
                clear: "Clear",
                data: "Data",
                export: "Export",
                jsonData: "JSON Data",
                pdfReport: "PDF Report",
                siteData: "Site Data",
                coordinates: "Coords",
                address: "Address",
                zip: "Zip",
                city: "City",
                parish: "Parish",
                context: "Context",
                area: "Area",
                vertices: "Vertices",
                penColor: "Pen Color",
                finish: "Finish",
                drawPolygon: "Draw Polygon",
                collapse: "Collapse",
                expand: "Expand",
                rights: "All Rights Reserved",
                privacy: "Privacy Policies and Cookies",
                terms: "Terms and Conditions",
                accessibility: "Accessibility Statement",
                footerText: "Land Staging™ is an exclusive methodology created by Segmento Urbano that assesses, clarifies, and projects the potential of land plots that are often considered “invisible” or difficult to place on the market. For more details: geral@segmentourbano.com"
            },
            pt: {
                searchPlaceholder: "Pesquisar Morada ou GPS...",
                locate: "Localizar",
                upload: "Carregar",
                uploadTooltip: "Mapas PDM, Caderneta Predial",
                clear: "Limpar",
                data: "Dados",
                export: "Exportar",
                jsonData: "Dados JSON",
                pdfReport: "Relatório PDF",
                siteData: "Dados do Local",
                coordinates: "Coord.",
                address: "Morada",
                zip: "C. Postal",
                city: "Concelho",
                parish: "Freguesia",
                context: "Envolvente",
                area: "Área",
                vertices: "Vértices",
                penColor: "Cor Caneta",
                finish: "Concluir",
                drawPolygon: "Desenhar Polígono",
                collapse: "Colapsar",
                expand: "Expandir",
                rights: "Todos os Direitos Reservados",
                privacy: "Políticas de Privacidade e Cookies",
                terms: "Termos e Condições",
                accessibility: "Declaração de Acessibilidade",
                footerText: "Land Staging™ é uma metodologia exclusiva criada pela Segmento Urbano que avalia, clarifica e projeta o potencial de terrenos muitas vezes considerados “invisíveis” ou de difícil colocação no mercado. Para mais detalhes: geral@segmentourbano.com"
            }
        };

        // --- Icons ---
        const Icons = {
            Search: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>,
            Trash: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>,
            FileJson: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/></svg>,
            Table: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 3v18"/><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/></svg>,
            X: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>,
            MapPin: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/><circle cx="12" cy="10" r="3"/></svg>,
            Crosshair: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="22" x2="18" y1="12" y2="12"/><line x1="6" x2="2" y1="12" y2="12"/><line x1="12" x2="12" y1="6" y2="2"/><line x1="12" x2="12" y1="22" y2="18"/></svg>,
            ChevronDown: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m6 9 6 6 6-6"/></svg>,
            ChevronUp: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m18 15-6-6-6 6"/></svg>,
            Download: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>,
            FilePdf: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M10 13v-2"/><path d="M10 11h1"/><path d="M10 14h1"/><path d="M14 11h-1v3h1"/></svg>,
            Upload: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>
        };

        // --- Layout Components ---

        // Header: Sticky at top
        const Header = ({ lang, setLang }) => (
            <header className="sticky top-0 w-full bg-white text-black border-b border-gray-200 px-6 py-4 flex items-center justify-between z-[2000] shadow-sm">
                <div className="flex items-baseline gap-4">
                    <h1 className="text-3xl font-arch font-normal tracking-wider uppercase">ATLAS - Landstaging™</h1>
                    <span className="text-xs text-gray-500 font-light tracking-widest lowercase">powered by segmento urbano</span>
                </div>
                
                <div className="flex items-center gap-3">
                    {/* Language Switch */}
                    <div className="text-xs font-medium tracking-wide text-gray-500">
                        <span 
                            onClick={() => setLang('pt')} 
                            className={`cursor-pointer transition-colors ${lang === 'pt' ? 'text-black font-bold' : 'hover:text-black'}`}
                        >PT</span>
                        <span className="mx-1">|</span>
                        <span 
                            onClick={() => setLang('en')} 
                            className={`cursor-pointer transition-colors ${lang === 'en' ? 'text-black font-bold' : 'hover:text-black'}`}
                        >EN</span>
                    </div>

                    {/* User Profile Placeholder */}
                    <div className="w-8 h-8 rounded-full bg-gray-100 border border-gray-300 flex items-center justify-center cursor-pointer hover:bg-gray-200 transition-colors" title="User Profile (Future Feature)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" className="text-gray-500">
                            <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"></path>
                            <circle cx="12" cy="7" r="4"></circle>
                        </svg>
                    </div>
                </div>
            </header>
        );

        // Footer: Collapsible
        const Footer = ({ t }) => {
            const [isExpanded, setIsExpanded] = useState(true);

            return (
                <footer className="bg-black text-white px-8 py-6 text-xs font-light z-40 w-full relative">
                    <div className="absolute top-4 right-6">
                         <button 
                            onClick={() => setIsExpanded(!isExpanded)}
                            className="flex items-center gap-2 text-gray-500 hover:text-white transition-colors uppercase tracking-widest text-[10px]"
                        >
                            {isExpanded ? t.collapse : t.expand}
                            {isExpanded ? <Icons.ChevronDown /> : <Icons.ChevronUp />}
                        </button>
                    </div>

                    {isExpanded && (
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-8 mb-8 pt-4 animate-fadeIn">
                            {/* Brand */}
                            <div className="lg:col-span-1">
                                <h2 className="uppercase font-bold tracking-widest mb-1 text-sm">segmento urbano</h2>
                                <p className="text-gray-400 tracking-wide text-[10px]">concept.construction.reality</p>
                            </div>

                            {/* Contact */}
                            <div>
                                <a href="mailto:geral@segmentourbano.com" className="hover:text-gray-300 transition-colors">geral@segmentourbano.com</a>
                            </div>

                            {/* Porto */}
                            <div>
                                <h3 className="uppercase font-bold mb-2 text-[10px] text-gray-500">Porto</h3>
                                <p className="leading-relaxed text-gray-300">
                                    Praça de D. João I 80<br/>
                                    4000-065 Porto, Portugal
                                </p>
                            </div>

                            {/* Lisboa */}
                            <div>
                                <h3 className="uppercase font-bold mb-2 text-[10px] text-gray-500">Lisboa</h3>
                                <p className="leading-relaxed text-gray-300">
                                    Av. Dom João II 50, Edifício Mar Vermelho,<br/>
                                    Parque das Nações<br/>
                                    1990-095 Lisboa, Portugal
                                </p>
                            </div>

                            {/* Luanda */}
                            <div>
                                <h3 className="uppercase font-bold mb-2 text-[10px] text-gray-500">Luanda</h3>
                                <p className="leading-relaxed text-gray-300">
                                    Rua Rainha Ginga 37 2º Direito<br/>
                                    Luanda, Angola
                                </p>
                            </div>
                        </div>
                    )}

                    <div className={`flex flex-col md:flex-row justify-between items-center gap-4 text-[10px] text-gray-500 uppercase tracking-wider ${isExpanded ? 'border-t border-gray-800 pt-6' : ''}`}>
                        <p>© 2026. Segmento Urbano. {t.rights}</p>
                        <div className="flex gap-6">
                            <a href="#" className="hover:text-white transition-colors">{t.privacy}</a>
                            <a href="#" className="hover:text-white transition-colors">{t.terms}</a>
                            <a href="#" className="hover:text-white transition-colors">{t.accessibility}</a>
                        </div>
                    </div>
                </footer>
            );
        };

        // --- Helper Functions ---
        const calculatePolygonArea = (latLngs) => {
            if (latLngs.length < 3) return 0;
            const earthRadius = 6378137; 
            let area = 0;
            for (let i = 0; i < latLngs.length; i++) {
                const j = (i + 1) % latLngs.length;
                const p1 = latLngs[i];
                const p2 = latLngs[j];
                const lat1 = p1.lat * (Math.PI / 180);
                const lng1 = p1.lng * (Math.PI / 180);
                const lat2 = p2.lat * (Math.PI / 180);
                const lng2 = p2.lng * (Math.PI / 180);
                area += (lng2 - lng1) * (2 + Math.sin(lat1) + Math.sin(lat2));
            }
            area = (area * earthRadius * earthRadius) / 2;
            return Math.abs(area);
        };

        const formatArea = (sqMeters) => {
            if (sqMeters > 10000) return `${(sqMeters / 10000).toFixed(4)} ha`;
            return `${sqMeters.toFixed(2)} m²`;
        };

        // --- Main Widget Component ---
        const MapWidget = ({ t }) => {
            const mapRef = useRef(null);
            const mapContainerRef = useRef(null); // Ref for PDF capture
            const mapInstance = useRef(null);
            const polygonLayer = useRef(null);
            const markerLayer = useRef(null);
            const drawingModeRef = useRef(false);
            const fileInputRef = useRef(null);

            // State
            const [searchQuery, setSearchQuery] = useState("");
            const [loading, setLoading] = useState(false);
            const [drawingMode, setDrawingMode] = useState(false);
            const [contextMenu, setContextMenu] = useState(null);
            const [polygonPoints, setPolygonPoints] = useState([]);
            const [selectedColor, setSelectedColor] = useState("#2563eb");
            const [polyArea, setPolyArea] = useState(0);
            
            // Export State
            const [showExportMenu, setShowExportMenu] = useState(false);
            const exportMenuRef = useRef(null);

            const [showMetadata, setShowMetadata] = useState(false);
            const [metadata, setMetadata] = useState({
                postalCode: "—", street: "—", streetNo: "—", municipality: "—", 
                freguesia: "—", nearby: "—", scale: "—", lat: "—", lng: "—"
            });

            const colors = ["#ef4444", "#f97316", "#eab308", "#22c55e", "#2563eb", "#a855f7", "#ec4899"];

            useEffect(() => {
                drawingModeRef.current = drawingMode;
                if (mapRef.current) {
                    if (drawingMode) {
                        mapRef.current.classList.add('drawing-mode');
                    } else {
                        mapRef.current.classList.remove('drawing-mode');
                    }
                }
            }, [drawingMode]);

            // --- Right Click Pan Logic ---
            useEffect(() => {
                if (!drawingMode || !mapInstance.current || !mapRef.current) return;

                const map = mapInstance.current;
                const container = map.getContainer(); 
                
                let isRightDown = false;
                let lastPoint = null;

                const onMouseDown = (e) => {
                    if (e.button === 2) { 
                        isRightDown = true;
                        lastPoint = { x: e.clientX, y: e.clientY };
                        container.classList.add('drawing-panning');
                    }
                };

                const onMouseMove = (e) => {
                    if (isRightDown && lastPoint) {
                        const dx = e.clientX - lastPoint.x;
                        const dy = e.clientY - lastPoint.y;
                        map.panBy([-dx, -dy], { animate: false });
                        lastPoint = { x: e.clientX, y: e.clientY };
                    }
                };

                const onMouseUp = (e) => {
                    if (e.button === 2) {
                        isRightDown = false;
                        lastPoint = null;
                        container.classList.remove('drawing-panning');
                    }
                };
                
                const onContextMenu = (e) => e.preventDefault();

                container.addEventListener('mousedown', onMouseDown);
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
                container.addEventListener('contextmenu', onContextMenu);

                return () => {
                    container.removeEventListener('mousedown', onMouseDown);
                    window.removeEventListener('mousemove', onMouseMove);
                    window.removeEventListener('mouseup', onMouseUp);
                    container.removeEventListener('contextmenu', onContextMenu);
                    container.classList.remove('drawing-panning');
                };
            }, [drawingMode]);

            // Close Export menu on outside click
            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (exportMenuRef.current && !exportMenuRef.current.contains(event.target)) {
                        setShowExportMenu(false);
                    }
                };
                document.addEventListener("mousedown", handleClickOutside);
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                };
            }, []);


            useEffect(() => {
                if (!mapInstance.current && mapRef.current) {
                    // preferCanvas: true fixes html2canvas rendering for vectors (polygons)
                    const map = L.map(mapRef.current, { zoomControl: false, preferCanvas: true }).setView([39.3999, -8.2245], 7);
                    
                    // Added crossOrigin: true for html2canvas support
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                        subdomains: 'abcd',
                        maxZoom: 20,
                        crossOrigin: true 
                    }).addTo(map);

                    L.control.zoom({ position: 'bottomright' }).addTo(map);
                    L.control.scale({ position: 'bottomright' }).addTo(map);
                    
                    mapInstance.current = map;

                    map.on('contextmenu', (e) => {
                        if (drawingModeRef.current) return; 
                        setContextMenu({
                            x: e.originalEvent.clientX,
                            y: e.originalEvent.clientY,
                            latlng: e.latlng
                        });
                    });

                    map.on('click', (e) => {
                        if (drawingModeRef.current) {
                            setPolygonPoints(prev => [...prev, e.latlng]);
                        } else {
                            setContextMenu(null);
                            pinLocation(e.latlng);
                        }
                    });
                }
            }, []);

            useEffect(() => {
                if (!mapInstance.current) return;
                if (polygonLayer.current) {
                    polygonLayer.current.remove();
                    polygonLayer.current = null;
                }
                if (polygonPoints.length > 0) {
                    polygonLayer.current = L.polygon(polygonPoints, {
                        color: selectedColor,
                        fillColor: selectedColor,
                        fillOpacity: 0.2,
                        weight: 2,
                        dashArray: null 
                    }).addTo(mapInstance.current);
                    setPolyArea(calculatePolygonArea(polygonPoints));
                } else {
                    setPolyArea(0);
                }
            }, [polygonPoints, selectedColor]);

            const pinLocation = (latlng) => {
                if (!mapInstance.current) return;
                if (markerLayer.current) markerLayer.current.remove();
                
                const customIcon = L.divIcon({
                    className: 'custom-pin',
                    html: `<div style="background-color:black; width:12px; height:12px; border-radius:50%; border:2px solid white; box-shadow:0 2px 4px rgba(0,0,0,0.2);"></div>`,
                    iconSize: [12, 12],
                    iconAnchor: [6, 6]
                });

                markerLayer.current = L.marker(latlng, { icon: customIcon }).addTo(mapInstance.current);
                mapInstance.current.flyTo(latlng, 16);
                fetchMetadata(latlng.lat, latlng.lng);
            };

            const fetchMetadata = async (lat, lng) => {
                setLoading(true);
                try {
                    const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`);
                    const data = await response.json();
                    
                    let nearbyStreets = "—";
                    try {
                        const overpassQuery = `[out:json][timeout:5];way["highway"]["name"](around:150,${lat},${lng});out tags;`;
                        const overpassRes = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(overpassQuery)}`);
                        const overpassData = await overpassRes.json();
                        if (overpassData.elements && overpassData.elements.length > 0) {
                            const currentRoad = data.address ? (data.address.road || "") : "";
                            const uniqueStreets = [...new Set(overpassData.elements.map(e => e.tags.name).filter(name => name && name !== currentRoad))].slice(0, 5);
                            nearbyStreets = uniqueStreets.length > 0 ? uniqueStreets.join(", ") : "None found nearby";
                        } else { nearbyStreets = "None found nearby"; }
                    } catch (e) { nearbyStreets = "Unavailable"; }

                    if (data && data.address) {
                        const addr = data.address;
                        const scaleCalc = "1:" + Math.round(559082264 / Math.pow(2, 16)).toLocaleString();
                        setMetadata({
                            postalCode: addr.postcode || "—",
                            street: addr.road || addr.pedestrian || "—",
                            streetNo: addr.house_number || "—",
                            municipality: addr.city || addr.town || addr.municipality || "—",
                            freguesia: addr.suburb || addr.village || addr.city_district || "—",
                            nearby: nearbyStreets,
                            scale: scaleCalc,
                            lat: lat.toFixed(6),
                            lng: lng.toFixed(6)
                        });
                        setShowMetadata(true);
                    }
                } catch (error) { console.error(error); } finally { setLoading(false); }
            };

            const handleSearch = async (e) => {
                e.preventDefault();
                setLoading(true);
                const gpsMatch = searchQuery.match(/^(-?\d+(\.\d+)?),\s*(-?\d+(\.\d+)?)$/);
                if (gpsMatch) {
                    pinLocation({ lat: parseFloat(gpsMatch[1]), lng: parseFloat(gpsMatch[3]) });
                    setLoading(false);
                } else {
                    try {
                        let res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery)}&countrycodes=pt&limit=1`);
                        let data = await res.json();
                        if (!data || data.length === 0) {
                            const relaxedQuery = searchQuery.replace(/,?\s*\d+\s*$/, '').trim();
                            if (relaxedQuery !== searchQuery && relaxedQuery.length > 2) {
                                res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(relaxedQuery)}&countrycodes=pt&limit=1`);
                                data = await res.json();
                            }
                        }
                        if (data && data.length > 0) {
                            pinLocation({ lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) });
                        } else { alert("Location not found."); }
                    } catch (err) { alert("Search error."); } finally { setLoading(false); }
                }
            };

            const startDrawing = () => {
                setDrawingMode(true);
                setPolygonPoints([]); // Reset points so we don't start with the right-click location
                setPolyArea(0);
                setContextMenu(null);
                // Removed the auto-add of the first point logic
            };

            const resetAll = () => {
                setDrawingMode(false);
                setPolygonPoints([]);
                setPolyArea(0);
                setSearchQuery("");
                if (markerLayer.current) markerLayer.current.remove();
                setShowMetadata(false);
            };

            const downloadJson = () => {
                const data = {
                    project: "ATLAS - Segmento Urbano",
                    metadata: metadata,
                    polygon: { area: formatArea(polyArea), coordinates: polygonPoints },
                    timestamp: new Date().toISOString()
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = 'atlas_segmento_urbano_analysis.json';
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                setShowExportMenu(false);
            };

            const handleDownloadPdf = () => {
                if (!mapContainerRef.current) return;
                
                const element = mapContainerRef.current;
                
                html2canvas(element, {
                    useCORS: true, // Crucial for map tiles
                    allowTaint: true,
                    logging: false,
                    scale: 2 // Better resolution
                }).then(canvas => {
                    const imgData = canvas.toDataURL('image/png');
                    
                    // A4 Vertical (Portrait) setup
                    const pdf = new jspdf.jsPDF({
                        orientation: 'portrait',
                        unit: 'mm',
                        format: 'a4'
                    });
                    
                    const pageWidth = pdf.internal.pageSize.getWidth();
                    const pageHeight = pdf.internal.pageSize.getHeight();
                    const margin = 15;
                    const contentWidth = pageWidth - (margin * 2);
                    
                    // --- Header ---
                    let yPos = margin;
                    pdf.setFont("helvetica", "bold");
                    pdf.setFontSize(16);
                    pdf.text("ATLAS - Landstaging™", margin, yPos);
                    
                    yPos += 6;
                    pdf.setFont("helvetica", "normal");
                    pdf.setFontSize(10);
                    pdf.setTextColor(100);
                    pdf.text("powered by segmento urbano", margin, yPos);
                    
                    yPos += 10; // Spacing before image

                    // --- Image Scaling Logic ---
                    const imgProps = pdf.getImageProperties(imgData);
                    const imgHeight = (imgProps.height * contentWidth) / imgProps.width;
                    
                    // Reserve approx 35mm for footer + buffer
                    const maxImgHeight = pageHeight - yPos - 35; 
                    
                    let finalImgWidth = contentWidth;
                    let finalImgHeight = imgHeight;
                    
                    if (imgHeight > maxImgHeight) {
                        finalImgHeight = maxImgHeight;
                        finalImgWidth = (imgProps.width * finalImgHeight) / imgProps.height;
                    }
                    
                    pdf.addImage(imgData, 'PNG', margin, yPos, finalImgWidth, finalImgHeight);

                    // --- Footer ---
                    const footerText = t.footerText;
                    
                    pdf.setFontSize(8);
                    pdf.setTextColor(128);
                    
                    const footerY = pageHeight - 25; 
                    
                    // Wrapped text
                    pdf.text(footerText, margin, footerY, {
                        maxWidth: contentWidth,
                        align: 'justify'
                    });

                    pdf.save('ATLAS_Landstaging_Report.pdf');
                    setShowExportMenu(false);
                }).catch(err => {
                    console.error("PDF generation failed:", err);
                    alert("Could not generate PDF. Please ensure map tiles loaded fully.");
                });
            };

            // Handle file upload click
            const handleFileUpload = (e) => {
                const files = e.target.files;
                if (files && files.length > 0) {
                    // Logic to handle files would go here.
                    // For now we just alert as per instructions to "allow upload"
                    alert(`Selected ${files.length} file(s) for upload.`);
                }
            };

            useEffect(() => {
                const closeMenu = () => setContextMenu(null);
                window.addEventListener('click', closeMenu);
                return () => window.removeEventListener('click', closeMenu);
            }, []);

            return (
                <div className="flex flex-col w-full relative bg-gray-50 min-h-screen">
                    
                    {/* Widget Toolbar */}
                    <div className="bg-white/80 backdrop-blur-sm border-b border-gray-200 px-4 py-3 flex flex-col md:flex-row gap-3 items-center justify-between z-30 sticky top-[73px]">
                        <div className="flex items-center gap-2"></div>
                        
                        <form onSubmit={handleSearch} className="flex-1 w-full flex gap-2 max-w-2xl">
                            <div className="relative flex-1">
                                <input 
                                    type="text" 
                                    className="w-full pl-9 pr-4 py-2 bg-gray-100 border-none rounded-none focus:ring-1 focus:ring-black focus:outline-none text-xs tracking-wide uppercase placeholder:text-gray-400 font-medium"
                                    placeholder={t.searchPlaceholder}
                                    value={searchQuery}
                                    onChange={(e) => setSearchQuery(e.target.value)}
                                />
                                <div className="absolute left-3 top-2.5 text-gray-400"><Icons.Search /></div>
                            </div>
                            <button 
                                type="submit" 
                                className="bg-black hover:bg-gray-800 text-white px-6 py-2 rounded-none text-xs uppercase tracking-widest transition-colors disabled:opacity-50"
                                disabled={loading}
                            >
                                {loading ? '...' : t.locate}
                            </button>
                        </form>
                    </div>

                    {/* Map Area - FIXED HEIGHT (Tall) */}
                    <div className="relative border-b border-gray-200 w-full h-[85vh]" ref={mapContainerRef}>
                        <div ref={mapRef} className="h-full w-full bg-gray-200"></div>

                        {/* Drawing Controls - FIXED FLOATING POSITION - IGNORED BY HTML2CANVAS */}
                        {drawingMode && (
                            <div 
                                data-html2canvas-ignore="true" 
                                className="fixed top-[140px] left-1/2 transform -translate-x-1/2 bg-white px-6 py-3 shadow-xl z-[1500] flex items-center gap-6 border border-gray-100 animate-bounce-in"
                            >
                                <span className="text-[10px] font-bold text-gray-400 uppercase tracking-widest">{t.penColor}</span>
                                <div className="flex gap-2">
                                    {colors.map(c => (
                                        <button key={c} className={`w-4 h-4 rounded-full transition-transform ${selectedColor === c ? 'ring-2 ring-black ring-offset-2 scale-110' : 'hover:scale-110'}`} style={{ backgroundColor: c }} onClick={(e) => { e.stopPropagation(); setSelectedColor(c); }} />
                                    ))}
                                </div>
                                <div className="h-4 w-px bg-gray-200"></div>
                                <button onClick={(e) => { e.stopPropagation(); setDrawingMode(false); }} className="text-[10px] uppercase tracking-widest font-bold text-black hover:underline">{t.finish}</button>
                            </div>
                        )}

                        {/* Context Menu */}
                        {contextMenu && !drawingMode && (
                            <div className="context-menu" style={{ top: contextMenu.y, left: contextMenu.x }} onClick={(e) => e.stopPropagation()}>
                                <div className="context-menu-item" onClick={startDrawing}><Icons.Crosshair /> {t.drawPolygon}</div>
                            </div>
                        )}

                        {/* Metadata Overlay - Compact Version */}
                        {showMetadata && (
                            <div className="absolute bottom-4 left-4 z-[500] w-[280px] metadata-overlay p-3 transition-all duration-300">
                                <div className="flex justify-between items-start mb-2 border-b border-black pb-1">
                                    <h3 className="font-arch text-base uppercase tracking-wider text-black">{t.siteData}</h3>
                                    <button onClick={() => setShowMetadata(false)} className="text-gray-400 hover:text-black transition-colors"><Icons.X /></button>
                                </div>
                                
                                <div className="space-y-2 font-mono text-[10px] text-gray-600">
                                    <div className="grid grid-cols-2 gap-x-2 gap-y-1">
                                        <div className="col-span-2 flex justify-between border-b border-dashed border-gray-200 pb-0.5">
                                            <span className="uppercase text-gray-400">{t.coordinates}</span>
                                            <span className="text-black">{metadata.lat}, {metadata.lng}</span>
                                        </div>
                                        <div className="col-span-2 flex justify-between border-b border-dashed border-gray-200 pb-0.5">
                                            <span className="uppercase text-gray-400">{t.address}</span>
                                            <span className="text-black text-right max-w-[150px] truncate">{metadata.street} {metadata.streetNo}</span>
                                        </div>
                                        <div className="flex justify-between border-b border-dashed border-gray-200 pb-0.5">
                                            <span className="uppercase text-gray-400">{t.zip}</span>
                                            <span className="text-black">{metadata.postalCode}</span>
                                        </div>
                                        <div className="flex justify-between border-b border-dashed border-gray-200 pb-0.5">
                                            <span className="uppercase text-gray-400">{t.city}</span>
                                            <span className="text-black">{metadata.municipality}</span>
                                        </div>
                                        <div className="col-span-2 flex justify-between border-b border-dashed border-gray-200 pb-0.5">
                                            <span className="uppercase text-gray-400">{t.parish}</span>
                                            <span className="text-black">{metadata.freguesia}</span>
                                        </div>
                                        <div className="col-span-2 pt-1">
                                            <span className="uppercase text-gray-400 block mb-0.5">{t.context}</span>
                                            <p className="text-black leading-tight">{metadata.nearby}</p>
                                        </div>
                                    </div>
                                    
                                    {polyArea > 0 && (
                                        <div className="mt-2 pt-2 border-t-2 border-black">
                                            <div className="flex justify-between items-end mb-1">
                                                <span className="uppercase font-bold text-black tracking-wider">{t.area}</span>
                                                <span className="text-sm font-light text-black">{formatArea(polyArea)}</span>
                                            </div>
                                            
                                            <div className="bg-gray-50 p-1.5 border border-gray-200">
                                                <span className="uppercase text-[9px] text-gray-400 block mb-0.5">{t.vertices}</span>
                                                <div className="max-h-20 overflow-y-auto custom-scrollbar">
                                                    {polygonPoints.map((pt, i) => (
                                                        <div key={i} className="flex justify-between py-0.5 text-gray-500 border-b border-gray-100 last:border-0">
                                                            <span>P.{String(i+1).padStart(2,'0')}</span>
                                                            <span>{pt.lat.toFixed(6)}, {pt.lng.toFixed(6)}</span>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Widget Footer Actions */}
                    <div className="bg-white border-b border-gray-200 p-4 z-30 flex justify-between items-center gap-3">
                        {/* Upload Button Section */}
                        <div>
                            <input 
                                type="file" 
                                ref={fileInputRef} 
                                className="hidden" 
                                multiple 
                                accept="image/*,application/pdf" 
                                onChange={handleFileUpload}
                            />
                            <button 
                                onClick={() => fileInputRef.current.click()}
                                title={t.uploadTooltip}
                                className="flex items-center gap-2 px-5 py-2 border border-gray-200 text-gray-600 hover:bg-gray-50 hover:border-gray-400 text-xs uppercase tracking-widest transition-all"
                            >
                                <Icons.Upload /> {t.upload}
                            </button>
                        </div>

                        {/* Existing Right-Side Buttons */}
                        <div className="flex gap-3">
                            <button 
                                onClick={resetAll}
                                className="flex items-center gap-2 px-5 py-2 border border-gray-200 text-gray-500 hover:text-red-600 hover:border-red-200 text-xs uppercase tracking-widest transition-all"
                            >
                                <Icons.Trash /> {t.clear}
                            </button>
                            
                            <button 
                                onClick={() => setShowMetadata(true)}
                                className="flex items-center gap-2 px-5 py-2 border border-gray-200 text-black hover:bg-gray-50 hover:border-black text-xs uppercase tracking-widest transition-all"
                            >
                                <Icons.Table /> {t.data}
                            </button>
                            
                            {/* Export Menu Container */}
                            <div className="relative" ref={exportMenuRef}>
                                <button 
                                    onClick={() => setShowExportMenu(!showExportMenu)}
                                    className={`flex items-center gap-2 px-6 py-2 bg-black text-white hover:bg-gray-800 text-xs uppercase tracking-widest transition-all ${showExportMenu ? 'bg-gray-800' : ''}`}
                                >
                                    <Icons.Download /> {t.export}
                                </button>

                                {/* Export Dropdown */}
                                {showExportMenu && (
                                    <div className="absolute bottom-full right-0 mb-2 w-48 bg-white border border-gray-200 shadow-xl rounded-sm py-1 z-50 animate-fadeIn">
                                        <button 
                                            onClick={downloadJson}
                                            className="w-full text-left px-4 py-3 hover:bg-gray-50 flex items-center gap-3 text-xs uppercase tracking-wider text-gray-700 transition-colors border-b border-gray-100"
                                        >
                                            <Icons.FileJson /> {t.jsonData}
                                        </button>
                                        <button 
                                            onClick={handleDownloadPdf}
                                            className="w-full text-left px-4 py-3 hover:bg-gray-50 flex items-center gap-3 text-xs uppercase tracking-wider text-gray-700 transition-colors"
                                        >
                                            <Icons.FilePdf /> {t.pdfReport}
                                        </button>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Layout Wrapper ---
        const App = () => {
            const [language, setLanguage] = useState('pt');
            const t = TRANSLATIONS[language];

            return (
                <div className="flex flex-col min-h-screen w-full bg-white">
                    <Header lang={language} setLang={setLanguage} />
                    <main className="flex-1 flex flex-col relative bg-gray-50">
                        <MapWidget t={t} />
                    </main>
                    <Footer t={t} />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>